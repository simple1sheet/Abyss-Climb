1. Eliminate the React runtime errors
Problem	Root cause	Fix
“No QueryClient set”	QueryClientProvider is missing (or not high enough in the tree) in the Android build. This often happens if you mount a different root component inside App.tsx for Capacitor.	1. Import & create once: ts import {QueryClient, QueryClientProvider} from '@tanstack/react-query'; const queryClient = new QueryClient();
2. Wrap all routes/UI (including service‑worker setup) in <QueryClientProvider client={queryClient}>...</QueryClientProvider>.
3. Never re‑create queryClient inside render functions.
“useEffect is not defined”	A component file has import { useState } from 'react' but later calls useEffect. Vite’s treeshake removes unused imports until Android’s minifier crashes.	Run pnpm vite build (or npm run build) before copy‑syncing; then scan warnings:
`grep -R "useEffect(" client/src

Quick test
npm run build && npx serve dist in your desktop browser must show a working PWA with no console errors before you touch Capacitor. If this fails, stop—Capacitor can’t fix a broken React bundle.

2. Harden Vite for mobile‑webview usage
vite.config.ts

ts
Kopieren
Bearbeiten
export default defineConfig({
  base: './',             // ✔ relative URLs so Android asset loader works offline
  build: {
    outDir: 'dist/public', // matches capacitor.config.ts
    emptyOutDir: true,
  },
  plugins: [react()],
});
Verify that index.html and service‑worker.js end up inside dist/public.

If you changed routing to BrowserRouter, switch to HashRouter (or MemoryRouter) for offline navigation—Android webviews ignore SW navigation fallback without a network layer.

3. Sync assets into the native project
Minimal repeatable sequence (what your build‑apk‑complete.sh should do):

bash
Kopieren
Bearbeiten
#!/usr/bin/env bash
set -euo pipefail
npm run build        # Vite → dist/public
npx cap copy android # copies fresh webDir
npx cap sync android # re‑writes AndroidManifest if needed
cd android
./gradlew assembleRelease  # or bundleRelease for .aab
Common pitfalls:

Old assets – always clean Gradle cache on CI: ./gradlew clean.

Duplicated index.html – ensure only one copy lives under android/app/src/main/assets/public/.

4. Diagnose WebView‑only issues
Enable remote debugging:
In MainActivity.java (or .kt) inside onCreate, add

java
Kopieren
Bearbeiten
WebView.setWebContentsDebuggingEnabled(true);
Connect the phone → Chrome DevTools → “Remote devices” to inspect console/network logs in real time.

Typical Vite HMR noise appears because dev‑server URLs are baked into the bundle when you run the dev build inside the WebView. Make sure you are using the production build created in Step 3.

5. Stable database connectivity for a mobile context
Thing to avoid	Why it breaks	Recommended mobile‑friendly pattern
Frontend → Neon directly	Mobile radio sleeps → cold‑starts each query → Neon serverless spins up too often; battery drain & timeouts.	Keep your existing Node/Express API. Host it on a low‑latency edge function (Neon + Vercel/Cloudflare). The mobile app talks to your API, not to the DB.
Single long‑lived PG pool	Capacitor keeps the pool idle; Neon closes it; first request hangs.	Use Neon’s @neondatabase/serverless driver (per‑request, stateless).
Unbounded connection count	Android may spawn parallel webviews during splash → connection storm.	In server/index.ts:
```ts
import { Pool } from '@neondatabase/serverless';		
export const pool = new Pool({ connectionString: process.env.DATABASE_URL, max: 1 });		

|
Kopieren
Bearbeiten

If you *must* connect client‑side (not recommended) then:

```ts
import { neon } from '@neondatabase/serverless';
// always inside an async function:
const sql = neon(process.env.NEON_URL!, { connectionTimeout: 3000 });
…but again: an HTTPS API is simpler, caches better, and lets you queue writes offline then sync when online.

6. Re‑run and package
Delete android/app/build to enforce a clean build.

Execute the shell script from Step 3.

Install the generated app-release.apk on a device: adb install -r app-release.apk.

Open logcat (adb logcat | grep Capacitor) and verify there are no red errors on launch.

🔑 Quick checklist (print & keep near terminal)
 npm run build succeeds, desktop PWA works offline

 QueryClientProvider wraps entire tree

 All hooks are imported (useEffect, useMemo, …)

 vite.config.ts → base: './', outDir matches Capacitor

 npx cap copy android after every rebuild

 WebView remote debugging shows no 404s

 Server uses Neon serverless driver or API tier

 ./gradlew assembleRelease completes with 0 errors

Follow the list top‑to‑bottom; the most common blocker is the very first one (React context/layout). Once the web bundle is solid, the APK layer is usually just “copy and compile.”

Good luck—ping me with any logcat trace or build output that still looks suspicious and we’ll drill deeper!